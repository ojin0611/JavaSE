07/20

## Oveview

[Chapter 1. Java Programming Language Overview](https://github.com/swacademy/JavaSE/blob/master/Chapter%201.%20Java%20Programming%20Language%20Overview.pdf)

[Chapter 2.  자바환경설정]([https://github.com/swacademy/JavaSE/blob/master/Chapter%202.%20Configuration%20for%20Lab.pdf](https://github.com/swacademy/JavaSE/blob/master/Chapter 2. Configuration for Lab.pdf))

# Chapter 3. Java Language Rules



중요 ASCII Code 값!

0~9 : 48~57

A~Z : 65~90

a~z : 97~122



[전체 유니코드표](http://www.unicode.org/charts/)

[한글 유니코드표](https://www.unicode.org/charts/PDF/UAC00.pdf)



Naming Convention

1. PascalCasing : HelloWorld, System
2. camelCasing : age, print(), tpdayDate
3. kebab-casing : \<my-salary>
4. snake_casing 



Java는 Pascal, camel 이용

클래스이름의 첫 글자는 대문자, 변수는 소문자





### 상수(constant)

변수와 달리 한번 값을 저장하면 다른 값으로 변경할 수 없는 값을 상수라고 한다. 상수 선언은 변수와 동일한데 단지 변수의 타입 앞에 키워드 final을 붙여주기만 하면 된다.

```java
final int MAX_SPEED = 10; // 상수 MAX SPEED를 선언 & 초기화

int max;
max = Integer.MAX_VALUE; // 자바에 저장되어있는 상수 값 사용하기
```



### 오버플로우 (Overflow)

오버플로우가 발생하면 에러가 생기지는 않지만 예상했던 결과를 얻지 못한다. 애초에 오버플로우가 발생하지 않게 충분한 크기의 타입을 선택해서 사용하면 된다.



## 화면에서 입력받기 - Scanner

자바에는 buffer라는 애가 있다.

keyboard의 입력을 받아들이는 것은 OS가 한다. 즉, 자바는 무슨 키보드를 쓰는지 관심이 없다.

`키보드 입력 > 메모리 > 입력 버퍼 > 자바`

자바의 입력 버퍼는 OS가 전달해준 입력값을 받아들인다. 이 때 사용하는 클래스가 **Scanner**다.

자바의 출력 버퍼에 있는 내용을 OS가 모니터로 내보낸다.



클래스 Scanner를 사용하기 위해서는 `import java.util.*`이 필요하다. (`java.lang` 을 제외하고는 모두 import가 필요함. `java.lang` 은 컴파일할 때 자바가 자동으로 불러온다.)

클래스는 new를 써야 메모리 주소가 생긴다.

```java
import java.util.*; //to import Scanner
Scanner scan; // 주소변수 선언
scan = new Scanner(System.in);

String name = scan.nextLine(); //\n을 포함한 한줄 모두 입력으로 받기
String email= scan.next(); //공백이 없는 값만 저장할 수 있음

/*
nextLine은 \n을 입력의 끝으로 받는다는 특징이 있다. 
scan.next() 이후에 scan.nextLine()이 등장할 경우 오류가 발생하는데, 
scan.next()가 입력으로 \n을 받지 않는다. 때문에 scan.nextLine()이 scan.next()와 동일한 값을 갖는 현상을 보인다.
*/


int sum = 65;

System.out.printf("총첨 : %d\n", sum);
System.out.printf("평균 : %.1f\n", sum/3. ); // 정수와 실수를 연산하면 결과가 실수가 된다.

```



### 값 저장과 stack, heap

기본형(int, double, boolean, ...) 변수는 heap에 값을 저장, 참조형(Scanner, ...) 변수는 heap에 **주소**를 저장.

int age가 stack에 있으면 24가 heap에 저장된다.

double height가 stack에 있으면 180.5이 heap에 저장된다.

Scanner scan이 stack에 있으면 그 `주소`가 heap에 저장된다. 그래서 그 변수에 무엇이 저장돼있는지 heap은 궁금해하지 않는다. 오직 그 변수의 주소만 궁금해할 뿐이다. 



## 실수를 저장하는 방법

영환님 알려주세요

float : 1(부호) + 8(지수) + 23(가수)