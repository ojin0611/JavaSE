07/27

# 7/24 시험 리뷰

## 비트연산자(&)와 논리연산자(&&)

비트연산자

```java
System.out.println(0xff00 & 0x00ff);  // 0
```



논리연산자

```java
System.out.println(0xff00 && 0x00ff); // error
System.out.println(5 && 7); //error
System.out.println(true && 5>6); //false

```



비트연산자(&)도 양 옆에 boolean을 넣었을 때 에러가 발생하지 않는다.

다만 논리연산자로 연산하면 && 기준 좌측에서 false일 때 우측의 연산을 시행하지 않아 **효율적**이지만, 비트연산자(&)로 boolean을 비교할 때는 true/false 여부와 상관없이 양쪽 모두 연산을 한다.



## 변수 초기화

for문 밖에서 선언하고 for문 안에서 할당을 할 경우, for문 밖에서 출력할 때 컴파일 에러가 발생한다.

즉, 출력문 기준에서 변수가 이미 **초기화**가 완벽하게 돼있어야한다. 

```java
// 이 코드는 컴파일 에러 발생함 (초기화하지 않았습니다.)

int sum; //초기화 안하면 에러나는데, 초기화 하면(int sum=0;) 값이 잘 나옴.
for (int i= 1; i<10; i+=2)
{
    sum = i*2;
}
System.out.println("결과 : "+sum);

```

그런데 do-while문을 이용하면 출력이 된다.

다시말해서, java입장에서는 for문이나 while문의 경우, 내부 loop가 아예 안돌경우를 대비해서 컴파일 에러를 낸다.

하지만 do-while문의 블럭에 있는 부분은 무조건 한 번 수행되므로 블럭 안에서 할당해주더라도 에러가 나지 않는다.

```java
String myString;
int myInt;
do
{
    myString = "Hello Java";
    myInt = 1024;
}
while (false);
System.out.println(myString + " " + myInt);

```



## boolean to integer

true = 00000001, false = 00000000 이라고 내부적으로 저장하지만 실제로 이 값을 1 또는 0으로 확인할 수는 없다.

숫자(정수)로 저장하고 싶다면 다음과 같은 방법을 이용한다.

```java
// boolean -> int
int myInt = myBoolean ? 1 : 0;
```



## 증감연산자

별로 중요하지않지만 중요할수도있는 내용

증감연산자(++,--)의 위치에 따라 연산 순서가 달라진다. 

단순히 증감연산자만 사용하는 경우(ex. i++;)에는 헷갈릴 일이 없지만

증감연산자를 이용하여 **할당**할 경우 값이 달라진다. 아래 코드를 참고

```java
// 증감연산자 
int a;
int b=10;
int c=10;
a = b++; // a= 10;
System.out.println(a +" "+b);
a = ++c; // a= 11;
System.out.println(a +" "+b);

```



# 반복문

## do-while

while문의 조건식과 블럭{}의 순서를 바꿔놓은 것이다. 때문에 최소 한 번은 수행될 것을 보장한다.



## continue

loop(반복)가 진행되는 도중에 continue문을 만나면 **반복문의 끝**으로 이동하여 다음 iteration(반복)으로 넘어간다.

charAt을 이용하여 비밀번호 비교 프로그램(굉장히 취약한)을 작성할 수 있다.

> myString.charAt(i) : myString의 i번째(시작=0) 위치하는 character를 반환한다. type은 char

```java
import java.util.Scanner;
public class ContinueDemo1 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String system_password = "1234";
		

		System.out.print("Enter a password : ");
		String user_password = scan.nextLine();

		int i = 0;
		for (; i<4 ;i++ ){
			if (system_password.charAt(i) == user_password.charAt(i))
			{
				continue;
			}
			else break;
		}
		if (i==4) System.out.println("Success");
		else System.out.println("Failure");
	}
}

```



## 이름붙은 반복문

다른 언어에 없는 goto 기능 대신, 루프문에 이름을 넣어줄 수 있다.

continue, break할 때 반복문의 이름(label)을 함께 기입하면 더 바깥에 있는 반복문도 continue 또는 break할 수 있다.

```java
public class LabelBreakContinueDemo {
	public static void main(String[] args) {
		outer : // label1
		for (int i=2; i<10; i++){
			inner: // label2
			for (int j=1; j<10; j++)
			{
				if (j==5) // if문에 {}없으면 한 줄만 실행하고 넘어간다.
					// break outer; 바깥 loop가 끝남.
					continue outer; //outer loop로 돌아감
				System.out.print(i +"*" + j + "=" + i*j + "  "); // if문에 들어가있지 않음
			}
			System.out.println();
		}
	}
}

```





### String 형변환 - parseInt, toString



String을 Integer로 또는 그 반대로 변환하는 방법

```java
Integer.parseInt(myString, 10); // string to integer. 10진수의 숫자로 myString을 인식!!

String,valueOf(myInt); // integer to string

Integer.toString(myInt, 2); // integer to string, 2진법. default = 10진수!
```



아래는 parseInt의 용법을 api에서 찾은것.

```
 parseInt("0", 10) returns 0
 parseInt("473", 10) returns 473
 parseInt("+42", 10) returns 42
 parseInt("-0", 10) returns 0
 parseInt("-FF", 16) returns -255
 parseInt("1100110", 2) returns 102
 parseInt("2147483647", 10) returns 2147483647
 parseInt("-2147483648", 10) returns -2147483648
 parseInt("2147483648", 10) throws a NumberFormatException
 parseInt("99", 8) throws a NumberFormatException
 parseInt("Kona", 10) throws a NumberFormatException
 parseInt("Kona", 27) returns 411787
```


최대 최소 = Math.max(), Math.min() 사용 가능!



# 배열(Array)

성격, 크기, 구조가 같은 자료형의 집합체



stack에 배열주소(4byte) 저장. 

heap에는 배열이 따다다닥 붙어있음. 자료형의 크기에 따라 메모리가 할당된다.

예를 들어, 4byte짜리 자료형으로 이루어진 배열이 있다면 각 값의 주소는 아래와 같다.

0x1000, 0x1004, 0x1008, 0x1016

배열을 저장하는 변수는 이 배열의 첫 번째 주소인 0x1000을 저장하고 있다.



배열은 한 번 만들면 확장이나 축소가 불가능하다.



배열의 초기화방법은 여러가지 있다.

```java
//-------------------------------------------------
// Declaration
int su;
int [] array; // [] 추가하면 주소변수가 선언됨.

// Creation 생성 (배열을 위한 단계)
array = new int[4]; //new는 단항연산자! 우측에서 좌측 순서대로

// Assignment
su = 5;
array[1] = 3;

System.out.printf("%d %d\n",array[0], array[1]);

//-------------------------------------------------
// Declaration
int [] array2;

// Creation & Assignment
// 배열에는 주소를 저장해야하기때문에, new로 heap에 배열을 생성하고 그 주소를 할당
array2 = new int[]{3,4,5,6}; // [] 안에 비워놔
System.out.println(array2[2]);

//-------------------------------------------------
// Declaration, Creation & Assignment --> initialize
int[] array3 = {3,4,5,6}; // 같은 라인에 둬야한다.
System.out.println(array3[3]);
```



배열의 길이는 `array.length` 를 이용한다!



---

7/28

배열은 데이터의 성격,크기,구조가 같다.

multiple data를 한개의 이름으로 다룬다.



배열 복사 방법은 두 가지가 있다.

```java
// shallow copy
int[] original = {1,2,3,4,5,6,7}
int[] target = {8,9,10,11,12}

System.arraycopy(original, 2, target, 0, 3);
// original[2]에서 target[0]으로 3개의 데이터 복사

// deep copy
target = original
```



null은 아무 주소도 가리키지 않는다는 뜻이다.



String은 사실상 char 배열이지만, 거기에 메소드 기능을 추가한 클래스다. 때문에 String 클래스 내에 char 하나씩 바꿔주기 위해서 char[]를 이용할 수 있다.

```java
String str = "서울시 강남구 역삼동";
char[] array= str.toCharArray();
for (int i=0; i<array.length; i++)
{
    System.out.printf("%3c",array[i]);
}
array[0] = '경'; array[1] = '기'; array[2] = '도';
System.out.println();
str = new String(array);
System.out.println(str);
```



다른 class들도 array를 만들어 줄 수 있다.

```java
//Student class는 다른 곳에 별도 파일 생성
Student chulsu = new Student();
chulsu.name = "김철수";

Student younghee = new Student();
younghee.name = "이영희";

Student jimin = new Student();
jimin.name = "한지민";

Student [] target = new Student[5]; //null로 초기화
Student [] original = {chulsu, younghee, jimin};
System.arraycopy(original, 0, target, 0, original.length); //original 배열의 값을 shallow-copy.
// 배열의 값은 주소이기때문에, chul, young, jim의 주소를 복사해서 target이 갖고있는 것

// 강화된 for문
for (Student std: target){ 
// target 배열의 원소 하나씩 꺼내기. 원소의 타입은 Student, 그 이름을 std라고 하자
    if(std!= null) System.out.println(std.name); 
}
```



---

7/29

# Eclipse 

## 설치

[홈페이지](https://www.eclipse.org/downloads/packages/)

설치 전에 이미 자바가 설치되어있어야한다!



1. Eclipse IDE for Java Developers : essential tools for Core Java
2. Eclipse IDE for **Enterprise** Java Developers : 나중에 웹 할때 필요

OS에 맞게 클릭 후, region 선택 > 다운로드됨

압축해제 후, C:\Program Files\ 로 복사

보통 소스는 src, 컴파일하면 bin에 들어간다.

## 설정

Window > Preferences > Font 검색



## 단축키

[정리된 사이트](https://seohs.tistory.com/488)

ctrl / : **이클립스**에서 사용되는 행**주석 단축키**. 문장 맨 앞에 // 가 자동적으로 붙습니다. 

ctrl shift / : 범위 **주석 단축키**

ctrl shift \ : 주석**처리를 풀기 위한 **단축키**

ctrl shift f : 들여쓰기 맞추기. 주석풀 때 들여쓰기가 꼬일 때 사용

ctrl i : 들여쓰기 조정

ctrl + : 폰트 확대

ctrl - : 폰트 축소

ctrl m : 코드화면 최대화

ctrl space : 자동완성

> —– 템플릿 사용 —–
>
> sysout 입력 후 **Ctrl + Space** : System.out.println(); 자동 입력됨
>
> ​    Windows > Preferences > JAVA > Editor > Templates에 추가 가능 
>
> try 입력한 후 **Ctrl + Space** : try-catch 문이 자동 완성
>
> for 입력한 후 **Ctrl + Space** : for 문 자동 완성







## 시작

1. 항상 Project를 만들고 시작한다.
   - 소스코드는 src에, default output 경로는 bin이다.
2. Project 내에 src에는 package가 있다. 
   - 폴더 안에 이미 파일이 있으면 default package가 자동생성된다.
3. package에 new > class 생성하면 (우리가 이전시간까지 만들던) 새로운 소스 코드 파일을 만들 수 있다.



# 배열

JOptionPane을 이용해서 출력도 가능하다.



## 2차원 배열

정사각형 배열(Rectangular Array)과 뒤틀린 배열(Ragged Array) 모두 가능하다.

2차원 배열의 경우, 1차원 배열에 각 층의 주소를 저장한다. 때문에 각 층마다 배열의 길이가 달라도 된다!



---

7/30

### 마방진 (magic square)

1~n^2 까지 숫자를 정사각형에 하나씩 넣어 각 행,열,대각선의 합이 같은 사각형을 만드는 방법은 아래와 같다.

1. 1을 첫 줄 중앙에 넣는다.
2. 다음 숫자는 이전 숫자의 우측 상단에 넣는다.
3. 만약 숫자가 3k+1이면 이전 숫자의 (우측 상단 대신) 하단에 넣는다.

```java
import java.util.Arrays;

public class MagicSquare {
	public static void main(String[] args) {
		int WIDTH = 3 ;
		int[][] square = new int[WIDTH][WIDTH];
		
		int i = 0;
		int j = WIDTH/2;
		square[i][j] = 1;
		for (int n=2; n<= WIDTH*WIDTH; n++) {
			if (n%WIDTH == 1) i++;
			else {
				i--;
				j++;
			}
			if (i<0) i += WIDTH;
			if (j>=WIDTH) j -= WIDTH;
			square[i][j] = n;
		}
		
		for (int n=0; n<WIDTH; n++)
		System.out.println(Arrays.toString(square[n]));
	}
}
```









### 변수 복습

변수는 타입에 따라 기본형 변수와 참조형 변수로 분류된다.

기본형에는 정수(byte,short,int,long),실수(double,float),char,boolean

참조형에는 문자열(String), 클래스가 있다.



변수를 선언위치에 따라 지역변수와 멤버변수로 나눌 수 있다.

> 자바의정석 p246
>
>  [어떤 메모리에 저장되는지 잘 설명해놓은 블로그](https://mainpower4309.tistory.com/4)  



클래스 파일이 저장되는 공간을 Method Area라고 한다.

![변수의 선언위치에 따른 분류](../img/methodarea-callstack-heap.png)



#### 0. 지역변수

지역변수의 선언위치는 **메소드나 생성자 내부** 로, 메소드 내에서만 사용이 가능한 변수다.

메소드가 종료되면 (중괄호가 닫히면) 자동으로 소멸된다.



멤버변수는 **클래스 영역에 선언**된 변수다. 클래스 변수와 인스턴스 변수로 나누어진다.

### 1. 클래스 변수 (a.k.a 전역변수)

클래스 변수란 클래스 내에서 static을 붙여서 선언하는 변수다.

한 번 선언되면 해당 클래스의 모든 인스턴스가 같은 저장공간을 가리키고, **전역변수**라고 부르기도 한다.

다른 클래스에서 선언한 변수도 static을 붙이면 (클래스변수이므로) 불러올 수 있다!



### 2. 인스턴스 변수

클래스의 인스턴스를 생성할 때 만들어진다. 그렇기 때문에 인스턴스 변수의 값을 읽어오거나 저장하기 위해서는 **먼저 인스턴스를 생성**해야한다.







# 메서드 (method)

특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것을 메서드라고 한다.

메서드는 선언부와 구현부로 나뉜다.

선언부는 return type, name, 매개변수 선언 총 3개로 구성돼있다.



메서드는 호출할 때 그제서야 일을 한다.

클래스 메서드는 인스턴스 메서드를 호출할 수 없다. 왜냐면, 클래스 메서드는 프로그램 시작하자마 이미 메모리에 올라가있는데, 인스턴스 메서드는 호출해줄 때 메모리에 올라가기 때문에 쓰려면 아직 없음.



## 인자(argument)와 매개변수(parameter)

```java
int add(int x, int y){ // x,y는 매개변수. 함수에서 받는 애 
    return x+y;
}

int result = add(3,5) // 3,5는 인자. 원본
```



## 메서드 호출과 메모리

1. 메서드가 호출되면 수행에 필요한만큼 메모리를 **스택(stack)**에 할당받는다.
2. 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
3. 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다.
4. 아래 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.







## 클래스 메소드, 인스턴스 메소드

class method

클래스 메소드 안에서 연산하면 값이 바뀐다!!

```java
public class HelloWorld2 {
	static String str = "Hello, World"; // class variable. 
	public static void main(String[] args) {
		HelloWorld2 hw = new HelloWorld2();
		System.out.println(HelloWorld2.str); // static, 즉, 클래스 변수는 클래스 이름으로 접근하는 것이 국룰이다.
		System.out.println(str); // 근데 여기서는 hw.str 할 필요가 없다! 같은 클래스기때문
	}
}
```



전역 메소드 불러오기!

```java
public class HelloWorld4 {
	public static void main(String[] args) {
		System.out.println(Test1.str);
	}
}

class Test1{
	static String str = "Hello, World"; //class variable
}
```







instance method

```java
public class HelloWorld3 {
	public static void main(String[] args) {
		// System.out.println(str); 다른 클래스에 있는 변수를 어케아라
		Test t = new Test(); // new 로 선언하면 heap의 메모리에 생성. 
		System.out.println(t.str); // 주소로 접근한다고 한다.
	}
}

class Test{
	String str = "Hello, World";
}
```





## 기타

Java 8, Java SE 14?