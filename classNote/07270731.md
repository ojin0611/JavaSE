07/27

# 7/24 시험 리뷰

## 비트연산자(&)와 논리연산자(&&)

비트연산자

```java
System.out.println(0xff00 & 0x00ff);  // 0
```



논리연산자

```java
System.out.println(0xff00 && 0x00ff); // error
System.out.println(5 && 7); //error
System.out.println(true && 5>6); //false

```



비트연산자(&)도 양 옆에 boolean을 넣었을 때 에러가 발생하지 않는다.

다만 논리연산자로 연산하면 && 기준 좌측에서 false일 때 우측의 연산을 시행하지 않아 **효율적**이지만, 비트연산자(&)로 boolean을 비교할 때는 true/false 여부와 상관없이 양쪽 모두 연산을 한다.



## 변수 초기화

for문 밖에서 선언하고 for문 안에서 할당을 할 경우, for문 밖에서 출력할 때 컴파일 에러가 발생한다.

즉, 출력문 기준에서 변수가 이미 **초기화**가 완벽하게 돼있어야한다. 

```java
// 이 코드는 컴파일 에러 발생함 (초기화하지 않았습니다.)

int sum; //초기화 안하면 에러나는데, 초기화 하면(int sum=0;) 값이 잘 나옴.
for (int i= 1; i<10; i+=2)
{
    sum = i*2;
}
System.out.println("결과 : "+sum);

```

그런데 do-while문을 이용하면 출력이 된다.

다시말해서, java입장에서는 for문이나 while문의 경우, 내부 loop가 아예 안돌경우를 대비해서 컴파일 에러를 낸다.

하지만 do-while문의 블럭에 있는 부분은 무조건 한 번 수행되므로 블럭 안에서 할당해주더라도 에러가 나지 않는다.

```java
String myString;
int myInt;
do
{
    myString = "Hello Java";
    myInt = 1024;
}
while (false);
System.out.println(myString + " " + myInt);

```



## boolean to integer

true = 00000001, false = 00000000 이라고 내부적으로 저장하지만 실제로 이 값을 1 또는 0으로 확인할 수는 없다.

숫자(정수)로 저장하고 싶다면 다음과 같은 방법을 이용한다.

```java
// boolean -> int
int myInt = myBoolean ? 1 : 0;
```



## 증감연산자

별로 중요하지않지만 중요할수도있는 내용

증감연산자(++,--)의 위치에 따라 연산 순서가 달라진다. 

단순히 증감연산자만 사용하는 경우(ex. i++;)에는 헷갈릴 일이 없지만

증감연산자를 이용하여 **할당**할 경우 값이 달라진다. 아래 코드를 참고

```java
// 증감연산자 
int a;
int b=10;
int c=10;
a = b++; // a= 10;
System.out.println(a +" "+b);
a = ++c; // a= 11;
System.out.println(a +" "+b);

```



# 반복문

## do-while

while문의 조건식과 블럭{}의 순서를 바꿔놓은 것이다. 때문에 최소 한 번은 수행될 것을 보장한다.



## continue

loop(반복)가 진행되는 도중에 continue문을 만나면 **반복문의 끝**으로 이동하여 다음 iteration(반복)으로 넘어간다.

charAt을 이용하여 비밀번호 비교 프로그램(굉장히 취약한)을 작성할 수 있다.

> myString.charAt(i) : myString의 i번째(시작=0) 위치하는 character를 반환한다. type은 char

```java
import java.util.Scanner;
public class ContinueDemo1 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String system_password = "1234";
		

		System.out.print("Enter a password : ");
		String user_password = scan.nextLine();

		int i = 0;
		for (; i<4 ;i++ ){
			if (system_password.charAt(i) == user_password.charAt(i))
			{
				continue;
			}
			else break;
		}
		if (i==4) System.out.println("Success");
		else System.out.println("Failure");
	}
}

```



## 이름붙은 반복문

다른 언어에 없는 goto 기능 대신, 루프문에 이름을 넣어줄 수 있다.

continue, break할 때 반복문의 이름(label)을 함께 기입하면 더 바깥에 있는 반복문도 continue 또는 break할 수 있다.

```java
public class LabelBreakContinueDemo {
	public static void main(String[] args) {
		outer : // label1
		for (int i=2; i<10; i++){
			inner: // label2
			for (int j=1; j<10; j++)
			{
				if (j==5) // if문에 {}없으면 한 줄만 실행하고 넘어간다.
					// break outer; 바깥 loop가 끝남.
					continue outer; //outer loop로 돌아감
				System.out.print(i +"*" + j + "=" + i*j + "  "); // if문에 들어가있지 않음
			}
			System.out.println();
		}
	}
}

```





### String 형변환 - parseInt, toString



String을 Integer로 또는 그 반대로 변환하는 방법

```java
Integer.parseInt(myString, 10); // string to integer. 10진수의 숫자로 myString을 인식!!

String,valueOf(myInt); // integer to string

Integer.toString(myInt, 2); // integer to string, 2진법. default = 10진수!
```



아래는 parseInt의 용법을 api에서 찾은것.

```
 parseInt("0", 10) returns 0
 parseInt("473", 10) returns 473
 parseInt("+42", 10) returns 42
 parseInt("-0", 10) returns 0
 parseInt("-FF", 16) returns -255
 parseInt("1100110", 2) returns 102
 parseInt("2147483647", 10) returns 2147483647
 parseInt("-2147483648", 10) returns -2147483648
 parseInt("2147483648", 10) throws a NumberFormatException
 parseInt("99", 8) throws a NumberFormatException
 parseInt("Kona", 10) throws a NumberFormatException
 parseInt("Kona", 27) returns 411787
```


최대 최소 = Math.max(), Math.min() 사용 가능!



# 배열(Array)

성격, 크기, 구조가 같은 자료형의 집합체



stack에 배열주소(4byte) 저장. 

heap에는 배열이 따다다닥 붙어있음. 자료형의 크기에 따라 메모리가 할당된다.

예를 들어, 4byte짜리 자료형으로 이루어진 배열이 있다면 각 값의 주소는 아래와 같다.

0x1000, 0x1004, 0x1008, 0x1016

배열을 저장하는 변수는 이 배열의 첫 번째 주소인 0x1000을 저장하고 있다.



배열은 한 번 만들면 확장이나 축소가 불가능하다.



배열의 초기화방법은 여러가지 있다.

```java
//-------------------------------------------------
// Declaration
int su;
int [] array; // [] 추가하면 주소변수가 선언됨.

// Creation 생성 (배열을 위한 단계)
array = new int[4]; //new는 단항연산자! 우측에서 좌측 순서대로

// Assignment
su = 5;
array[1] = 3;

System.out.printf("%d %d\n",array[0], array[1]);

//-------------------------------------------------
// Declaration
int [] array2;

// Creation & Assignment
// 배열에는 주소를 저장해야하기때문에, new로 heap에 배열을 생성하고 그 주소를 할당
array2 = new int[]{3,4,5,6}; // [] 안에 비워놔
System.out.println(array2[2]);

//-------------------------------------------------
// Declaration, Creation & Assignment --> initialize
int[] array3 = {3,4,5,6}; // 같은 라인에 둬야한다.
System.out.println(array3[3]);
```



배열의 길이는 `array.length` 를 이용한다!



---

7/28

배열은 데이터의 성격,크기,구조가 같다.

multiple data를 한개의 이름으로 다룬다.



배열 복사 방법은 두 가지가 있다.

```java
// shallow copy
int[] original = {1,2,3,4,5,6,7}
int[] target = {8,9,10,11,12}

System.arraycopy(original, 2, target, 0, 3);
// original[2]에서 target[0]으로 3개의 데이터 복사

// deep copy
target = original
```



null은 아무 주소도 가리키지 않는다는 뜻이다.



String은 사실상 char 배열이지만, 거기에 메소드 기능을 추가한 클래스다. 때문에 String 클래스 내에 char 하나씩 바꿔주기 위해서 char[]를 이용할 수 있다.

```java
String str = "서울시 강남구 역삼동";
char[] array= str.toCharArray();
for (int i=0; i<array.length; i++)
{
    System.out.printf("%3c",array[i]);
}
array[0] = '경'; array[1] = '기'; array[2] = '도';
System.out.println();
str = new String(array);
System.out.println(str);
```



다른 class들도 array를 만들어 줄 수 있다.

```java
//Student class는 다른 곳에 별도 파일 생성
Student chulsu = new Student();
chulsu.name = "김철수";

Student younghee = new Student();
younghee.name = "이영희";

Student jimin = new Student();
jimin.name = "한지민";

Student [] target = new Student[5]; //null로 초기화
Student [] original = {chulsu, younghee, jimin};
System.arraycopy(original, 0, target, 0, original.length); //original 배열의 값을 shallow-copy.
// 배열의 값은 주소이기때문에, chul, young, jim의 주소를 복사해서 target이 갖고있는 것

// 강화된 for문
for (Student std: target){ 
// target 배열의 원소 하나씩 꺼내기. 원소의 타입은 Student, 그 이름을 std라고 하자
    if(std!= null) System.out.println(std.name); 
}
```

