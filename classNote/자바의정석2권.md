8/13

자바의 정석 2권 시작!

# Chapter 10. 날짜와 시간 & 형식화 (date, time and formatting)

## 날짜

여러 가지 방법이 있다. 각 방법마다 장단점이 있다.

1. java.util.Date
2. java.util.Calendar
3. java.util.Calendar & java.util.GregorianCalendar
4. java.text.DateFormat & java.util.Date
5. java.text.SimpleDateFormat & java.util.Date
6. **printf(String.format()) --> java.util.Formatter**



Date class를 이용하면 쉽게 날짜를 얻을 수 있는데 포맷이 미국식이라 맘에 안든다.

GregorianCalendar 클래스의 api를 이용해 손쉽게 달력을 만들 수 있다.

...

6번 `printf`가 제일 편하다.

```java
System.out.printf("오늘은 %1$ty년 %1$tm년 %1$tm월 %1$td일입니다.", new Date()); 
// String.format 을 사용해도 동일한 결과
```



*시간 단원은 중요하지 않으므로 pass*



# Chapter 11. 컬렉션 프레임워크 (Collections Framework)

인터페이스 List, Set의 공통된 부분을 뽑아 Collection 인터페이스를 정의했다. 이외에도 Map 이라는 인터페이스도 있다. 각각의 자료구조가 무엇인지는 따로 공부하는 것으로 하고, 각각의 api를 Java에서 구현할 수 있다는 것 정도만 알고있자.

| 인터페이스 | 특징                                                         |
| :--------: | ------------------------------------------------------------ |
|    List    | 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다. (예. 대기자명단) |
|            | 구현클래스 : ArrayList, LinkedList, Stack, Vector            |
|    Set     | 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다. (예. 양의 정수집합, 소수의 집합) |
|            | 구현클래스 : HashSet, TreeSet                                |
|    Map     | 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집함. 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다. (예. 우편번호, 전화번호) |
|            | 구현클래스 : HaspMap, TreeMap, Hashtable, Properties         |



## List

### ArrayList

ArrayList는 List 인터페이스를 상속받은 클래스로 크기가 가변적으로 변하는 선형리스트입니다. 일반적인 배열과 같은 순차리스트이며 인덱스로 내부의 객체를 관리한다는점등이 유사하지만 한번 생성되면 크기가 변하지 않는 배열과는 달리 ArrayList는 객체들이 추가되어 저장 용량(capacity)을 초과한다면 자동으로 부족한 크기만큼 저장 용량(capacity)이 늘어난다는 특징을 가지고 있습니다.

 ArrayList를 사용할시에는 ArrayList에 타입을 명시해주는것이 좋습니다. 제너릭스 개념을 이용하면 아래와 같이 선언할 수 있다.

```java
ArrayList<String> list = new ArrayList<String>();
list.add(2, "Hi"); // index 2 뒤에 추가
list.remove(1); // index 1 제거
list.size(); // list 크기 구하기
```



### Vector

Vector는 List 인터페이스의 구현 클래스중 하나로, ArrayList와 동일한 내부구조를 가지고 있습니다. ArrayList와 마찬가지로 Vector내부에 값이 추가되면 자동으로 크기가 조절되며 그다음 객체들은 한 자리씩 뒤로 이동됩니다. 

하지만 모든 것이 다 똑같은 것은 아니고 Vector와 Arraylist의 한가지 다른 점이 있는데 Vector는 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드들이 실행할 수 있습니다. 그래서 멀티 스레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있습니다. 

```java
Vector<Integer> v = new Vector<Integer>();
Vector<Integer> list = new Vector<Integer>(Arrays.asList(1,2,3)); // 이렇게도 쓴다.

v.add(3); //값 추가
v.remove(1);  //index 1 제거
System.out.println(v.size()); //Vector 자료 개수
```

그 외에도 elementAt(index), removeElementAt(index) 등의 메소드들이 있다.



### Stack

Vector 클래스를 상속받아, 전형적인 스택 메모리구조의 클래스를 제공 후입선출(LIFO) 시멘틱을 따르는 자료구조

`peek()` 메소드와 `pop()`메소드, `push()` 메소드 등을 Vector에게 상속받아서 사용한다.



### Queue

Stack과 달리 별도의 인터페이스 형태로 제공된다. Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는데 가장 많이 사용된다.

선입선출(FIFO) 시멘틱을 따르는 자료구조다.

`peek()`, `poll()`, `add()` 등의 메소드를 Collection 인터페이스에게 상속받아서 사용한다.



## Set

### hashset, treeset

hashset은 set 인터페이스를 상속받은 클래스로, 둘 다 중복된 요소를 저장하지 않는다.

hashset은 순서에 상관없이 자료를 저장하는 반면 treeset은 정렬된 순서로 저장한다. 둘 다 입력받은 순서와는 관련없이 자료를 저장한다는 특징이 있다.



## Map

### HashMap

Hasthtable의 새로운 버전이다. Map의 특징대로 key와 value를 묶어서 하나의 데이터(entry)로 저장한다는 특징을 갖는다. 그리고 해싱(hashing)을 사용하기때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.

```java
HashMap map = new HashMap();
//map.put("Jan", 1);
map.put("DBDriver", "com.jdbc.oracle.OracleDriver");
map.put("DBUrl", "jdbc:oracle:thin:@127.0.0.1:1520:ORCL");
map.put("DBUser", "jimin");
map.put("DBPassword", "12345678");

Set<String> set = map.keySet();
Iterator<String> iters = set.iterator();
while(iters.hasNext()) {
    String key = iters.next();
    System.out.println(key + " --> " + map.get(key));
}
```

put 메소드로 key, value를 입력하고, keySet 메소드로 key를 set 자료형으로 구할수있다.



### Properties

Hashtable을 상속받아 구현한 것으로, (String, String) 형태로 데이터를 저장한다. 주로 애플리케이션의 환경설정과 관련된 속성을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공한다.





## 그 외..

### class Iterator

Java에서 제공하는 컬렉션은 보관하고 있는 자료들을 순차적으로 접근하면서 처리할 때 사용하는 Iterator 형식을 제공하고 있습니다. Iterator는 반복자라고 부르며 컬렉션 종류에 관계없이 같은 방법으로 프로그래밍 할 수 있게 해 줍니다.

Iterator 형식에는 다음 요소가 있는지 판별하는 `hasNext` 메서드와 다음으로 이동하는 `next` 메서드, 읽어 온 요소를 삭제하는 `remove` 메서드 등을 제공합니다.



### Comparator와 Comparable

Arrays.sort()를 호출만 하면 컴퓨터가 알아서 배열을 정렬하는 것처럼 보이지만, 사실은 Character클래스의 인터페이스 Comparable 구현에 의해 정렬됐던 것이다. Comparator와 Comparable의 실제 소스를 보자.

```java
public interface Comparator{
    int compare(Object o1, Object o2);
    boolean equals(Object obj);
}

public interface Comparable{
    public int compareTo(Object to);
}
```



Comparable 인터페이스는 기본 정렬기준을 구현하는데 사용하고, Comparator는 기본정렬기준 외에 다른기준으로 정렬하고자할 때 사용한다. 각각의 인터페이스를 implements할 때 오버라이드하는 메소드가 다르다는것 정도만 이해하자.



### Collections

Arrays가 배열과 관련된 메서드를 제공하는것처럼, Collections는 컬렉션과 관련된 메서드를 제공한다. 더 손쉽게 정렬할 수 있다는 정도만 알고 넘어가자.

```java
Collections.sort(this.vector); // 오름차순
Collections.reverse(vector); // 뒤집기
```





# Chapter 12. 지네릭스(generics), 열거형(enumeration), 애너테이션(annotation)

## 지네릭스

지네릭스(generics)는 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일 시 **타입 체크**를 해주는 기능이다.

지네릭스는 **타입 안정성을 제공**하고, 타입체크와 형변환을 생략할 수 있어 **코드가 간결**해진다.



지네릭 타입은 클래스와 메서드에 선언할 수 있다. 클래스에 선언하는 지네릭 타입은 아래와 같다.

```java
// 클래스 선언
class Box<T>{
    T item;
    
    void setItem(T item){this.item = item;}
    T getItem(){return item;}
}

// 사용
Box<String> b = new Box<String>(); // T 대신 실제타입 넣어야함
b.setItem(new Object()); // error
b.setItem("ABC"); // OK
String item = b.getItem(); // OK
```

※ 제네릭스는 선언할 수 있는 타입이 객체 타입입니다. int는 기본자료형이기 때문에 들어갈 수 없으므로 int를 객체화시킨 wrapper클래스를 사용해야 합니다.





### 용어

지네릭스 관련 용어를 아래와 같이 정리할 수 있다.

```java
class Box<T>{}
/*
Box<T> : 지네릭 클래스. T의 Box타입 또는 T Box라고 읽는다.
T : 타입 변수 또는 타입 매개변수. (T는 타입 문자)
Box : 원시 타입 (raw type)
*/

Box<String> b = new Box<String>();
/*
String : 대입된 타입, 매개변수화된 타입
Box<String> : 지네릭 타입 호출
*/
```



지네릭 클래스 Box의 객체를 생성할 때, 객체별로 다른 타입을 지정하는 것은 적절하다. 



### 제한

static 멤버는 타입변수에 지정된 타입에 관계없이 동일해야하기때문에 타입변수 T를 사용할 수 없다. 마찬가지로 메소드의 매개변수로 T 타입을 입력받을 수 없다. (근데 List<T>는 되더라)

또한, 지네릭 타입의 배열을 직접 생성할 수 없다. (ex. `new T[10]; // error`) new 연산자는 컴파일 시점에 타입T가 뭔지 정확히 알아야하기때문이다.

```java
class Box<T>{
    static T item; //error
    static int compare(T t1, T t2){ ... } // error
}
```



### 생성과 사용

```java
// 클래스 선언 (가정)
class Box<T> {...}
class Apple extends Fruit {...}
class Grape extends Fruit {...}
class FruitBox extends Box {,,,}

// 생성 : 타입변수 일치 필요
Box<Apple> appleBox = new Box<Apple>() ; // OK
Box<Apple> appleBox = new Box<Grape>() ; // error
Box<Fruit> appleBox = new Box<Apple>() ; // error
Box<Apple> appleBox = new FruitBox<Apple>() ; // Ok. 다형성

// 사용 : 다른 타입의 인스턴스 대입 불가능
appleBox.add(new Apple()); // OK
appleBox.add(new Grape()); // error. Apple객체만 추가가능

// 사용 : 자손형 인스턴스 대입 가능
Box<Fruit> fruitBox = new Box<Fruit>();
fruitBox.add(new Apple()); // OK


```





### 타입 매개변수 제한하기

클래스의 타입 매개변수 T에 지정할 수 있는 타입의 종류를 제한하기 위해서 `extends`를 이용한다.

```java
class FruitBox<T extends Fruit>{ ... } // Fruit의 자손만 타입으로 지정가능

FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
fruitBox.add(new Apple()); // OK
```

타입 매개변수가 인터페이스를 구현해야할 때도 마찬가지로 `extends`를 사용한다. 클래스의 자손이면서 인터페이스를 구현하고싶으면 `&` 기호로 연결한다.

```java
interface Eatable{}
class FruitBox<T extends Eatable> {...}
class FruitBox<T extends Fruit & Eatable> {...} // 동시에 구현하고싶을때

```



### 와일드 카드

그런데, 제너릭스의 매개변수 타입을 단 하나로 두면 불편하다. 심지어 지네릭 타입이 다른 것만으로는 오버로딩도 안된다 (메서드 중복 정의). 매개변수의 조상형, 자손형을 모두 쓸 수 있도록 `?`를 사용한다.

<? extends T> : 와일드카드의 상한 제한. T와 그 자손들만 가능

<? super T> : 와일드 카드의 하한 제한. T와 그 조상들만 가능

<?> : 제한 없음. 모든 타입이 가능. <? extends Object>와 동일





## 제너릭 메서드

리턴 타입에 지네릭 타입이 선언된 메소드를 제너릭 메서드라고 한다. 

**지네릭 클래스에 정의된** 타입 매개변수 T와 **지네릭 메서드에 정의된** 타입 매개변수 T는 전혀 **별개의 것**이다.

아래와같이 리턴타입에 지네릭 타입이 선언돼있다.

```java
//sort 메소드는 Car의 자식이면서 동시에 Comparable interface를 구현한 클래스만 받는다는 뜻.
static <T extends Car & Comparable> void sort(List<T> carList) {  //generic method
    System.out.println("<<Before Sorting>>");
    System.out.println(carList);
    Object [] array = carList.toArray();
    Arrays.sort(array);
    System.out.println("<<After Sorting>>");
    System.out.println(Arrays.toString(array));
}

```



실제로 해당 클래스가 T타입이더라도 해당 메소드에서 쓰이는 T는 어쩌다 생긴것만 같은 것이지 K나 M으로 써도 무방하다. 위 코드의 선언부는 아래 코드를 다르게 작성한 것이다. 

```java
static void sort(List<T extends Car & Comparable> carList){...}
```

즉, 메서드의 매개변수에 들어오는 변수의 타입을 정해주기 위해 제너릭 메서드를 사용하는 것이다.

위의 `sort()` 메소드를 해석하면

1. 타입 T를 요소로 하는 List를 매개변수로 허용한다.
2. T는 Car를 상속한 클래스임과 동시에 Comparable을 구현한 클래스여야한다.





---

8/15


