8/13

자바의 정석 2권 시작!

# Chapter 10. 날짜와 시간 & 형식화 (date, time and formatting)

## 날짜

여러 가지 방법이 있다. 각 방법마다 장단점이 있다.

1. java.util.Date
2. java.util.Calendar
3. java.util.Calendar & java.util.GregorianCalendar
4. java.text.DateFormat & java.util.Date
5. java.text.SimpleDateFormat & java.util.Date
6. **printf(String.format()) --> java.util.Formatter**



Date class를 이용하면 쉽게 날짜를 얻을 수 있는데 포맷이 미국식이라 맘에 안든다.

GregorianCalendar 클래스의 api를 이용해 손쉽게 달력을 만들 수 있다.

...

6번 `printf`가 제일 편하다.

```java
System.out.printf("오늘은 %1$ty년 %1$tm년 %1$tm월 %1$td일입니다.", new Date()); 
// String.format 을 사용해도 동일한 결과
```



*시간 단원은 중요하지 않으므로 pass*



# Chapter 11. 컬렉션 프레임워크 (Collections Framework)

인터페이스 List, Set의 공통된 부분을 뽑아 Collection 인터페이스를 정의했다. 이외에도 Map 이라는 인터페이스도 있다. 각각의 자료구조가 무엇인지는 따로 공부하는 것으로 하고, 각각의 api를 Java에서 구현할 수 있다는 것 정도만 알고있자.

| 인터페이스 | 특징                                                         |
| :--------: | ------------------------------------------------------------ |
|    List    | 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다. (예. 대기자명단) |
|            | 구현클래스 : ArrayList, LinkedList, Stack, Vector            |
|    Set     | 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다. (예. 양의 정수집합, 소수의 집합) |
|            | 구현클래스 : HashSet, TreeSet                                |
|    Map     | 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집함. 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다. (예. 우편번호, 전화번호) |
|            | 구현클래스 : HaspMap, TreeMap, Hashtable, Properties         |



## List

### ArrayList

ArrayList는 List 인터페이스를 상속받은 클래스로 크기가 가변적으로 변하는 선형리스트입니다. 일반적인 배열과 같은 순차리스트이며 인덱스로 내부의 객체를 관리한다는점등이 유사하지만 한번 생성되면 크기가 변하지 않는 배열과는 달리 ArrayList는 객체들이 추가되어 저장 용량(capacity)을 초과한다면 자동으로 부족한 크기만큼 저장 용량(capacity)이 늘어난다는 특징을 가지고 있습니다.

 ArrayList를 사용할시에는 ArrayList에 타입을 명시해주는것이 좋습니다. 제너릭스 개념을 이용하면 아래와 같이 선언할 수 있다.

```java
ArrayList<String> list = new ArrayList<String>();
list.add(2, "Hi"); // index 2 뒤에 추가
list.remove(1); // index 1 제거
list.size(); // list 크기 구하기
```



### Vector

Vector는 List 인터페이스의 구현 클래스중 하나로, ArrayList와 동일한 내부구조를 가지고 있습니다. ArrayList와 마찬가지로 Vector내부에 값이 추가되면 자동으로 크기가 조절되며 그다음 객체들은 한 자리씩 뒤로 이동됩니다. 

하지만 모든 것이 다 똑같은 것은 아니고 Vector와 Arraylist의 한가지 다른 점이 있는데 Vector는 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드들이 실행할 수 있습니다. 그래서 멀티 스레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있습니다. 

```java
Vector<Integer> v = new Vector<Integer>();
Vector<Integer> list = new Vector<Integer>(Arrays.asList(1,2,3)); // 이렇게도 쓴다.

v.add(3); //값 추가
v.remove(1);  //index 1 제거
System.out.println(v.size()); //Vector 자료 개수
```

그 외에도 elementAt(index), removeElementAt(index) 등의 메소드들이 있다.



### Stack

Vector 클래스를 상속받아, 전형적인 스택 메모리구조의 클래스를 제공 후입선출(LIFO) 시멘틱을 따르는 자료구조

`peek()` 메소드와 `pop()`메소드, `push()` 메소드 등을 Vector에게 상속받아서 사용한다.



### Queue

Stack과 달리 별도의 인터페이스 형태로 제공된다. Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는데 가장 많이 사용된다.

선입선출(FIFO) 시멘틱을 따르는 자료구조다.

`peek()`, `poll()`, `add()` 등의 메소드를 Collection 인터페이스에게 상속받아서 사용한다.



## Set

### hashset, treeset

hashset은 set 인터페이스를 상속받은 클래스로, 둘 다 중복된 요소를 저장하지 않는다.

hashset은 순서에 상관없이 자료를 저장하는 반면 treeset은 정렬된 순서로 저장한다. 둘 다 입력받은 순서와는 관련없이 자료를 저장한다는 특징이 있다.



## Map

### HashMap

Hasthtable의 새로운 버전이다. Map의 특징대로 key와 value를 묶어서 하나의 데이터(entry)로 저장한다는 특징을 갖는다. 그리고 해싱(hashing)을 사용하기때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.

```java
HashMap map = new HashMap();
//map.put("Jan", 1);
map.put("DBDriver", "com.jdbc.oracle.OracleDriver");
map.put("DBUrl", "jdbc:oracle:thin:@127.0.0.1:1520:ORCL");
map.put("DBUser", "jimin");
map.put("DBPassword", "12345678");

Set<String> set = map.keySet();
Iterator<String> iters = set.iterator();
while(iters.hasNext()) {
    String key = iters.next();
    System.out.println(key + " --> " + map.get(key));
}
```

put 메소드로 key, value를 입력하고, keySet 메소드로 key를 set 자료형으로 구할수있다.



### Properties

Hashtable을 상속받아 구현한 것으로, (String, String) 형태로 데이터를 저장한다. 주로 애플리케이션의 환경설정과 관련된 속성을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공한다.





## 그 외..

### class Iterator

Java에서 제공하는 컬렉션은 보관하고 있는 자료들을 순차적으로 접근하면서 처리할 때 사용하는 Iterator 형식을 제공하고 있습니다. Iterator는 반복자라고 부르며 컬렉션 종류에 관계없이 같은 방법으로 프로그래밍 할 수 있게 해 줍니다.

Iterator 형식에는 다음 요소가 있는지 판별하는 `hasNext` 메서드와 다음으로 이동하는 `next` 메서드, 읽어 온 요소를 삭제하는 `remove` 메서드 등을 제공합니다.



### Comparator와 Comparable

Arrays.sort()를 호출만 하면 컴퓨터가 알아서 배열을 정렬하는 것처럼 보이지만, 사실은 Character클래스의 인터페이스 Comparable 구현에 의해 정렬됐던 것이다. Comparator와 Comparable의 실제 소스를 보자.

```java
public interface Comparator{
    int compare(Object o1, Object o2);
    boolean equals(Object obj);
}

public interface Comparable{
    public int compareTo(Object to);
}
```



Comparable 인터페이스는 기본 정렬기준을 구현하는데 사용하고, Comparator는 기본정렬기준 외에 다른기준으로 정렬하고자할 때 사용한다. 각각의 인터페이스를 implements할 때 오버라이드하는 메소드가 다르다는것 정도만 이해하자.



### Collections

Arrays가 배열과 관련된 메서드를 제공하는것처럼, Collections는 컬렉션과 관련된 메서드를 제공한다. 더 손쉽게 정렬할 수 있다는 정도만 알고 넘어가자.

```java
Collections.sort(this.vector); // 오름차순
Collections.reverse(vector); // 뒤집기
```





# Chapter 12. 지네릭스(generics), 열거형(enumeration), 애너테이션(annotation)

## 지네릭스

지네릭스(generics)는 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일 시 **타입 체크**를 해주는 기능이다.

지네릭스는 **타입 안정성을 제공**하고, 타입체크와 형변환을 생략할 수 있어 **코드가 간결**해진다.



지네릭 타입은 클래스와 메서드에 선언할 수 있다. 클래스에 선언하는 지네릭 타입은 아래와 같다.

```java
// 클래스 선언
class Box<T>{
    T item;
    
    void setItem(T item){this.item = item;}
    T getItem(){return item;}
}

// 사용
Box<String> b = new Box<String>(); // T 대신 실제타입 넣어야함
b.setItem(new Object()); // error
b.setItem("ABC"); // OK
String item = b.getItem(); // OK
```

※ 제네릭스는 선언할 수 있는 타입이 객체 타입입니다. int는 기본자료형이기 때문에 들어갈 수 없으므로 int를 객체화시킨 wrapper클래스를 사용해야 합니다.





### 용어

지네릭스 관련 용어를 아래와 같이 정리할 수 있다.

```java
class Box<T>{}
/*
Box<T> : 지네릭 클래스. T의 Box타입 또는 T Box라고 읽는다.
T : 타입 변수 또는 타입 매개변수. (T는 타입 문자)
Box : 원시 타입 (raw type)
*/

Box<String> b = new Box<String>();
/*
String : 대입된 타입, 매개변수화된 타입
Box<String> : 지네릭 타입 호출
*/
```



지네릭 클래스 Box의 객체를 생성할 때, 객체별로 다른 타입을 지정하는 것은 적절하다. 



### 제한

static 멤버는 타입변수에 지정된 타입에 관계없이 동일해야하기때문에 타입변수 T를 사용할 수 없다. 마찬가지로 메소드의 매개변수로 T 타입을 입력받을 수 없다. (근데 List<T>는 되더라)

또한, 지네릭 타입의 배열을 직접 생성할 수 없다. (ex. `new T[10]; // error`) new 연산자는 컴파일 시점에 타입T가 뭔지 정확히 알아야하기때문이다.

```java
class Box<T>{
    static T item; //error
    static int compare(T t1, T t2){ ... } // error
}
```



### 생성과 사용

```java
// 클래스 선언 (가정)
class Box<T> {...}
class Apple extends Fruit {...}
class Grape extends Fruit {...}
class FruitBox extends Box {,,,}

// 생성 : 타입변수 일치 필요
Box<Apple> appleBox = new Box<Apple>() ; // OK
Box<Apple> appleBox = new Box<Grape>() ; // error
Box<Fruit> appleBox = new Box<Apple>() ; // error
Box<Apple> appleBox = new FruitBox<Apple>() ; // Ok. 다형성

// 사용 : 다른 타입의 인스턴스 대입 불가능
appleBox.add(new Apple()); // OK
appleBox.add(new Grape()); // error. Apple객체만 추가가능

// 사용 : 자손형 인스턴스 대입 가능
Box<Fruit> fruitBox = new Box<Fruit>();
fruitBox.add(new Apple()); // OK


```





### 타입 매개변수 제한하기

클래스의 타입 매개변수 T에 지정할 수 있는 타입의 종류를 제한하기 위해서 `extends`를 이용한다.

```java
class FruitBox<T extends Fruit>{ ... } // Fruit의 자손만 타입으로 지정가능

FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
fruitBox.add(new Apple()); // OK
```

타입 매개변수가 인터페이스를 구현해야할 때도 마찬가지로 `extends`를 사용한다. 클래스의 자손이면서 인터페이스를 구현하고싶으면 `&` 기호로 연결한다.

```java
interface Eatable{}
class FruitBox<T extends Eatable> {...}
class FruitBox<T extends Fruit & Eatable> {...} // 동시에 구현하고싶을때

```



### 와일드 카드

그런데, 제너릭스의 매개변수 타입을 단 하나로 두면 불편하다. 심지어 지네릭 타입이 다른 것만으로는 오버로딩도 안된다 (메서드 중복 정의). 매개변수의 조상형, 자손형을 모두 쓸 수 있도록 `?`를 사용한다.

<? extends T> : 와일드카드의 상한 제한. T와 그 자손들만 가능

<? super T> : 와일드 카드의 하한 제한. T와 그 조상들만 가능

<?> : 제한 없음. 모든 타입이 가능. <? extends Object>와 동일





## 제너릭 메서드

리턴 타입에 지네릭 타입이 선언된 메소드를 제너릭 메서드라고 한다. 

**지네릭 클래스에 정의된** 타입 매개변수 T와 **지네릭 메서드에 정의된** 타입 매개변수 T는 전혀 **별개의 것**이다.

아래와같이 리턴타입에 지네릭 타입이 선언돼있다.

```java
//sort 메소드는 Car의 자식이면서 동시에 Comparable interface를 구현한 클래스만 받는다는 뜻.
static <T extends Car & Comparable> void sort(List<T> carList) {  //generic method
    System.out.println("<<Before Sorting>>");
    System.out.println(carList);
    Object [] array = carList.toArray();
    Arrays.sort(array);
    System.out.println("<<After Sorting>>");
    System.out.println(Arrays.toString(array));
}

```



실제로 해당 클래스가 T타입이더라도 해당 메소드에서 쓰이는 T는 어쩌다 생긴것만 같은 것이지 K나 M으로 써도 무방하다. 위 코드의 선언부는 아래 코드를 다르게 작성한 것이다. 

```java
static void sort(List<T extends Car & Comparable> carList){...}
```

즉, 메서드의 매개변수에 들어오는 변수의 타입을 정해주기 위해 제너릭 메서드를 사용하는 것이다.

위의 `sort()` 메소드를 해석하면

1. 타입 T를 요소로 하는 List를 매개변수로 허용한다.
2. T는 Car를 상속한 클래스임과 동시에 Comparable을 구현한 클래스여야한다.





---

8/18

# Chapter 13. 쓰레드 thread

## 프로세스와 쓰레드

프로세스는 간단히 말해 실행중인 프로그램이다. 프로그램 실행시 OS로부터 실행에 필요한 메모리를 할당받아 프로세스가 된다.

프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 쓰레드다. 모든 프로세스에는 최소한 하나이상의 쓰레드가 존재하며 둘 이상의 쓰레드를 가진 프로세스를 멀티쓰레드 프로세스라고 한다.

CPU의 코어가 한번에 단 하나의 작업만 수행할 수 있으므로 실제로 동시에 처리되는 작업의 개수는 코어의 개수와 일치한다. 실제로는 각 코어가 아주 짧은시간동안 여러 작업을 번갈아가며 수행함으로써 여러 작업들이 모두 동시에 수행되는것처럼 보인다.



멀티쓰레딩의 장점은 크게 4가지 있다.

```
CPU의 사용률을 향상시킨다.
자원을 보다 효율적으로 사용할 수 있다.
사용자에 대한 응답성이 향상된다.
작업이 분리되어 코드가 간결해진다.
```

동기화와 교착상태 등의 단점도 있다.

main() 메소드를 실행하는동안 쓰레드로 생성한 객체가 run() 메소드를 실행한다.



## 쓰레드의 구현과 실행

쓰레들를 구현하는 방법은 2가지가 있다.

1. Thread class 상속받기

   ```java
   public class Main extends Thread{
       @Override
       public void run(){
           // ...
       }
   
   	public static void main(String[] args){
           Main m = new Main();
           m.start(); // m.run() 실행
       }
   }
   ```

   

2. Runnable interface 구현하기

    ```java
    Thread t = new Thread(obj, name);
    t.start(); 
    ```



자바는 클래스 다중상속이 불가능하기때문에, 다른 클래스를 상속받고싶을 때는 Runnable interface에서 run() 메소드만 오버라이드해서 쓰레드를 구현할 수 있다.



### 데몬 쓰레드 daemon thread

데몬 쓰레드는 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다. 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제로 종료된다.

데몬 쓰레드는 일반 쓰레드의 작성방법과 실행방법이 같다. 다만 쓰레드를 생성한 다음 실행하기전에 `setDaemon(true)`를 호출하기만하면 된다.





# 

## Thread 관련 메소드

#### stop()

Thread의 stop() 안전하게 이용할 수 있는 방법 중 하나는, 스레드의 run() 메소드가 정상적으로 종료 되도록 유도하는 것이다. 아래와 같이 스레드의 마지막 부분에서 플래그의 값을 변경하는 작업을 통해서 스레드가 정상적으로 종료 될 수 있도록 유도하는 것이 최선의 방법이다.

```java
private boolean isStop = false;
void stop() {
    this.isStop = true;
}
@Override
public void run() {
    while(! isStop) {
        try {
            Thread.sleep(100);  //0.001
        }catch(InterruptedException ex) {}
    }
}
```



#### interrupt()

Thread의 interrupt() 메소드는 스레드가 일시 정지 상태에 있을 때 InterruptedException 예외를 발생시키는 역할을 한다. 이것을 이용하면 Thread의 run() 메소드를 정상 종료시킬 수 있다. 

```java
public class InterruptExample { 
    public static void main(String[] args) { 
        Thread thread = new PrintThread(); 
        thread.start(); 
        try { 
            Thread.sleep(1000); 
        } catch (InterruptedException e) {} 
        thread.interrupt(); //스레드를 종료시키기 위해 InterruptedException을 발생시킴 } }
    }
}
```



#### yield()

#### join()

#### sleep()

run() 메소드는 무한루프인데, main() 메소드에서 이를 멈추는 방법은 sleep()이 있다.

> sleep() 메소드는 반드시 try-catch 구문을 씌워줘야한다. 잡아야할 예외는 InterruptedException



#### wait()

#### synchronized



# Chapter 14. 람다와 스트림 Lambda & stream

## 람다

lambda expression : 익명 함수

> 메소드는 특정 클래스에 반드시 속해야하지만, 함수는 하나의 독립적인 기능을 한다.

리턴타입과 메서드 이름을 생략할 수 있다. 경우에 따라 변수의 타입도 생략할 수 있다.

```java
public class LambdaDemo {
	public static void main(String[] args) {
		MyInterface mi = (a, b) -> a + b;
			
		int result = mi.calculate(5, 9);
		System.out.println("result = " + result);
	}
}

@FunctionalInterface
public interface MyInterface {
	int calculate(int a, int b);
	//int add(int a, int b);
}

```

## 함수형 인터페이스

위의 코드에서 `@FunctionalInterface`라는 annotation을 주목해보자. 람다식은 사실 메서드가 아나고, 익명 클래스의 객체와 동등하다. 익명 객체의 메서드를 호출하려면 참조변수가 있어야하고, 이 참조변수의 타입이 위 코드의 인터페이스 `MyInterface`가 된다.

이처럼 하나의 메서드가 선언된 인터페이스를 정의하면 기존의 자바의 규칙들을 어기지않으면서 자연스럽게 람다식을 다룰 수 있다. 이 때의 인터페이스를 **함수형 인터페이스**라고 부르기로 했다.



## 함수형 인터페이스 타입의 매개변수와 반환타입

메서드의 매개변수가 `MyFunction` 타입이면, 이 메서드는 호출할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야한다는 뜻이다.

```java
void method(MyFunction f){
    ...
}

MyFunction f = () -> System.out.println("My");
method(f);
```

또는 참조변수 없이 아래와같이 **직접 람다식을 매개변수로 지정**하는 것도 가능하다. 

```java
method(() -> System.out.println("My")); // 람다식 자체를 매개변수로 지정
```





# Chapter 15. 입출력 I/O



8/19 할 일

정리 : Chap 13. Thread 메소드들

정리 : Chap15. IODemo, IODemo1, FileInputStreamDemo