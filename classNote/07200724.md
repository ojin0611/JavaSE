07/20

## Oveview

[Chapter 1. Java Programming Language Overview](https://github.com/swacademy/JavaSE/blob/master/Chapter%201.%20Java%20Programming%20Language%20Overview.pdf)

[Chapter 2.  자바환경설정]([https://github.com/swacademy/JavaSE/blob/master/Chapter%202.%20Configuration%20for%20Lab.pdf](https://github.com/swacademy/JavaSE/blob/master/Chapter 2. Configuration for Lab.pdf))

# Chapter 3. Java Language Rules



중요 ASCII Code 값!

0~9 : 48~57

A~Z : 65~90

a~z : 97~122



[전체 유니코드표](http://www.unicode.org/charts/)

[한글 유니코드표](https://www.unicode.org/charts/PDF/UAC00.pdf)



Naming Convention

1. PascalCasing : HelloWorld, System
2. camelCasing : age, print(), tpdayDate
3. kebab-casing : \<my-salary>
4. snake_casing 



Java는 Pascal, camel 이용

클래스이름의 첫 글자는 대문자, 변수는 소문자





### 상수(constant)

변수와 달리 한번 값을 저장하면 다른 값으로 변경할 수 없는 값을 상수라고 한다. 상수 선언은 변수와 동일한데 단지 변수의 타입 앞에 키워드 final을 붙여주기만 하면 된다.

```java
final int MAX_SPEED = 10; // 상수 MAX SPEED를 선언 & 초기화

int max;
max = Integer.MAX_VALUE; // 자바에 저장되어있는 상수 값 사용하기
```



### 오버플로우 (Overflow)

오버플로우가 발생하면 에러가 생기지는 않지만 예상했던 결과를 얻지 못한다. 애초에 오버플로우가 발생하지 않게 충분한 크기의 타입을 선택해서 사용하면 된다.



## 화면에서 입력받기 - Scanner

자바에는 buffer라는 애가 있다.

keyboard의 입력을 받아들이는 것은 OS가 한다. 즉, 자바는 무슨 키보드를 쓰는지 관심이 없다.

`키보드 입력 > 메모리 > 입력 버퍼 > 자바`

자바의 입력 버퍼는 OS가 전달해준 입력값을 받아들인다. 이 때 사용하는 클래스가 **Scanner**다.

자바의 출력 버퍼에 있는 내용을 OS가 모니터로 내보낸다.



클래스 Scanner를 사용하기 위해서는 `import java.util.*`이 필요하다. (`java.lang` 을 제외하고는 모두 import가 필요함. `java.lang` 은 컴파일할 때 자바가 자동으로 불러온다.)

클래스는 new를 써야 메모리 주소가 생긴다.

```java
import java.util.*; //to import Scanner
Scanner scan; // 주소변수 선언
scan = new Scanner(System.in);

String name = scan.nextLine(); //\n을 포함한 한줄 모두 입력으로 받기
String email= scan.next(); //공백이 없는 값만 저장할 수 있음

/*
nextLine은 \n을 입력의 끝으로 받는다는 특징이 있다. 
scan.next() 이후에 scan.nextLine()이 등장할 경우 오류가 발생하는데, 
scan.next()가 입력으로 \n을 받지 않는다. 때문에 scan.nextLine()이 scan.next()와 동일한 값을 갖는 현상을 보인다.
*/


int sum = 65;

System.out.printf("총첨 : %d\n", sum);
System.out.printf("평균 : %.1f\n", sum/3. ); // 정수와 실수를 연산하면 결과가 실수가 된다.

```



### 값 저장과 stack, heap

기본형(int, double, boolean, ...) 변수는 stack에 값을 저장, 참조형(Scanner, ...) 변수는 stack에 **주소** (4바이트)를 저장하고 그 주소(heap)를 찾아가면 값이 heap에 저장돼있다.

int age가 stack에 있으면 24가 그 변수에 바로 저장된다.

double height가 stack에 있으면 180.5이 그 변수에 바로 저장된다.

Scanner scan이 stack에 있으면 그 `주소`가 stack에 저장된다. 그 주소를 찾아가면 heap에 그 값들이 저장돼있다.

Class Car 가 있다면 sonata.name이 저장된 주소를 저장한다.



## 실수를 저장하는 방법

실수 저장 방법은 부호(Sign), 지수(Exponent), 가수(Mantissa)을 이용하는 것이다.

`±M × 2^E `

float : 1(부호) + 8(지수) + 23(가수) = 32bit (4byte)

- 지수의 경우 -127~128을 표현할 수 있는데, 양의 무한대와 음의 무한대를 위해 양끝값을 제외하여 -126~127까지 표현할 수 있다.
- 따라서 float타입으로 표현할 수 있는 지수부분의 최대값은 2^127이다.
- 가수의 경우 2진수 23자리, 약 7자리의 10진수를 저장할 수 있다. double은 더 많이

double : 1 + 11 + 52 = 64bit (8byte)





### VSCode / EditPlus

Core Java (Java SE)의 경우, ANSI 인코딩을 표준으로 사용한다.

VSCode는 항상 UTF-8을 표준으로 사용하는데 EditPlus는 ANSI 인코딩이 표준이다.

나중에 웹+자바(ex. Servlet) 할 때는 utf-8이 표준이지만 지금은 코어자바 수업을 하기때문에 EditPlus를 이용한다.



---

7/21

## 기본형

논리형을 저장할 땐 1byte에 저장한다. (00000000, 00000001)

문자형 저장할 때는 'A'를 저장하는것이 아닌, 65를 이진화한 값을 저장한다.



## 참조형

Annotation, Array, Class, Enumeration, Interface

문자열 String은 primitive type이 아닌 class다! 그래서 원래 할당할 때 new를 이용해줘야하는데 자바가 귀찮으니까 new 없이도 만들수있게해줬다.

Class 맨처음 만들면 크기는 4byte



## 값복사

hoooni는 chulsu의 age 값(heap에 있음)을 복사했다.

1. 대상 : primitive type
2. 동작 : 원본이 바뀐다고 카피본이 바뀌지 않는다.
  즉, 원본과 카피본은 서로 다르다(서로 연결되어있지 않다).

```java
public class ReferenceCopyTest {
	public static void main(String[] args) {
		Student chulsu = new Student(); chulsu.age = 24;
		Student hoooni = new Student(); hoooni.age = chulsu.age;
		chulsu.age = 50;

		System.out.printf("철수는 %d살\n", chulsu.age); //50
		System.out.printf("훈이는 %d살\n", hoooni.age); //24
	}
}

class Student{
	int age;
}
```



## 주소복사

hoooni는 chulsu의 값을 복사한 것이 아니라 stack에 있는 chulsu의 (heap)주소를 복사했다!

이 때 hoooni.age의 주소와 연결이 끊어지고, 버려진 age를 `garbage`라고 한다.

접근할 수 없는 이런 메모리들(garbage)을 처리해주는 애가 garbage collector!

1. 대상 : 참조형(Reference Type)
2. 동작 : 같은 주소를 복사하기때문에 값이 함께 바뀐다.
3. 예외 : String 

```java
public class ReferenceCopyTest1 {
	public static void main(String[] args) {
		Student chulsu = new Student(); chulsu.age = 24;
		// Student hoooni = new Student(); hoooni.age = chulsu.age;
		Student hoooni = new Student();
		hoooni = chulsu;
		chulsu.age = 50;

		System.out.printf("철수는 %d살\n", chulsu.age); //50
		System.out.printf("훈이는 %d살\n", hoooni.age); //50
	}
}

class Student{
	int age;
}
```



## Cast or Conversion

1. **자동**형변환(암시적 형변환, Implicit Conversion, promotion)
   - 4 + 3.14 --> 4.0 + 3.14 --> 7.14
   - 4byte + 8byte --> 8byte + 8byte
   - String + int --> String + String
   - 작은 쪽이 큰 쪽으로 변화한다.
2. **강제**형변환(명시적 형변환, Explicit Conversion, demotion)
   - 큰쪽 --> 작은쪽



```
1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
2. 기본형과 참조형은 서로 형변환할 수 없다.
3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만,
	값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.
```



# Chapter 4. Expressions and Operators

### 클래스변수

공유되는 변수

클래스 이름으로 접근한다.

static이 붙어있음.

초기값이 자동으로 설정된다.



API에서 찾았을 때, static이 붙어있으면 클래스이름.메소드로 불러온다.

Integer.toBinaryString()



### 인스턴스변수

공유되지 않는다.

초기값이 자동으로 설정된다.

주소로 접근한다.



### 지역변수

local variable





---

Github 사용법

학원에서 집갈때

1. git add .

   변경사항 저장

2. git commit -m "07/21"

   변경사항에 대한 메세지 입력

3. git push 

   업로드

집에서 복습할때

1. git pull

   다운로드



