08/10

instanceof 복습





## 다른 경로에 있는 파일 저장/ 불러오기

다양한 옵션이 있다.

1. package import
2. classpath
3. jar



> 테스트는 D드라이브 아무 폴더를 기준으로 진행되고있습니다. 



### 파일 저장. package

#### cmd

컴파일 결과인 클래스파일의 저장경로는 현재 경로가 default다. 이 저장경로를 바꾸기위해서는 `-d mydirectory`를 이용한다.

```
javac -d C:/Temp Employee.java
```

> 위를 실행하면 현재 경로에있는 Employee.java를 실행하고, C:/Temp에 Employee.class를 저장한다.



Main.java에 있는 main 함수가 **같은 경로 내에 있는** Employee.java에 있는 Employee 클래스를 가져다쓴다고 해보자. 

```
javac Main.java
```

> 위를 실행하면 컴파일결과로 현재 폴더에 Main.class와 Employee.class를 생성한다.
>
> 자바는 메인을 실행했을 때, **자바 파일**을 찾아가서, 해당파일의 클래스가 없다면 그 때 생성한다.



#### java

자바파일에서 저장경로를 설정할 때 **package** 를 이용해준다.

```java
package kr.co.sist.libs;

public class Employee{
    public String name = "Sally";
}
```

>  위의 컴파일 구문 `javac -d C:/Temp Employee.java`를 실행하면 현재 경로에있는 Employee.java를 실행하고 C:/Temp/kr/co/sist/libs 에 Employee.class를 저장한다.





### 파일 불러오기. import, classpath, jar

#### 1. 같은 패키지

같은 패키지에 있는 파일은 불러오는데 문제가 없지만 다른 패키지에 있는 파일은 인식을 못한다.

다른 패키지에 저장돼있는 java, class 파일을 불러오고싶을 때 **import** 를 이용한다.

> import문은 package문 다음, class선언 이전에 선언한다.



```java
import kr.co.sist.libs.Employee;

public class Main {
	public static void main(String[] args) {
		Employee emp = new Employee();
		System.out.println("Name = " + emp.name);
	}
}

// 근데 이상태에서 `javac Main.java` 하면 에러 난다. 컴파일러가 저 디렉토리를 못찾는다.
```



static import라는 녀석도 있는데, 이를 사용하면 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

```java
import static java.lang.System.out;
import static java.lang.Math.*;

public class StaticImportDemo {
	public static void main(String[] args) {
		out.println("Hello, World");  // System 생략 가능!
		out.println("Real Pi = "+PI); // Math 생략가능! 3.141592653589793
		
		double rand = random(); // 내가 만든 메소드가 먼저나옴~ㅋㅋ
		out.println("My random double = " + rand); // 2.718
	}
	
	static double random() {
		out.println("Fake random ^^");
		return 2.718;
	}
}

```





#### 2. classpath



아래 두가지 경우도 가능하지만 보통 위의 경우가 대부분 쓰인다.

> import kr.co.sist.libs.*;
>
> kr.co.sist.libs.Employee emp = new kr.co.sist.libs.Employee();



다른 경로에 있는 파일을 불러오고싶을때는 cmd에서 **classpath (또는 -cp)**를 사용한다.

```
java -cp .;C:/Temp Main
```



클래스경로 (classpath)를 매번 지정하기 귀찮으니까 환경변수 > 시스템변수에 추가해주자.

> 환경변수 > 시스템변수 > 변수:CLASSPATH , 값: .;C:/Temp
>
> 띄어쓰기하면 에러

이렇게 하면 `javac Main.java` `java Main`이 먹힌다!

 

#### 3. jar

파일을 불러오는 기본 경로에 JRE System Library가 있다.

jar 파일을 만들어서 JRE System Library에 넣어도되고, 패키지에 별도의 경로(Reference Library)를 추가해주면 된다.



#### jar 만드는 방법

> 도움말은 cmd에서 jar --help를 쳐본다.



`C:\Temp> jar cvf mylib.jar kr/`

jar : jar파일 만들게

-c : create the archive

-v : verbose. generate verbose output on standard output

-f : archive file name.

mylib.jar : 파일이름

kr/ : 폴더 kr 이하에 있는 모든 파일들을 묶겠다는 뜻!



#### 새로운 경로 Eclipse에 저장하기

eclipse > 프로젝트 위에 우클릭 > Build path > Libraries > Classpath 선택 > Add External JARs > jar파일 선택 > Apply

그러면 해당 프로젝트 안에 Referenced Libraries가 생긴다.



## 제어자 (modifier)

제어자는 접근제어자와 그외로 나눌수 있다.

접근 제어자 (access modifier)

- public : 같은 클래스, 같은 패키지, 자손 클래스와 그 밖에서도 접근가능하다.
- protected : 같은 클래스, 같은 패키지, 자손클래스에서만 접근가능
- (default) : 따로 선언하지않으면 default. 같은 클래스와 패키지
- private : 오직 같은 클래스 내에서



그 외

- static, final, abstract, native, transient, synchronized



### final 

변수를 상수로 만들어준다.

상수이름은 모두 대문자, 중간구분은 `_`

클래스를 더이상 상속할 수 없게 만들어준다.



까먹을까봐 다시 정리..

>  멤버변수(+상수) 초기화는 생성자
>
> 클래스변수(+상수) 초기화는 초기화블럭 



### abstract

abstract class = 추상클래스.  미완성 설계도에 비유할 수 있다.

미완성 메서드(abstract method)를 포함하고있다는 의미다.

목적은 **다형성의 강제화**로 상속을 통해 구현해주어야한다. 상속안하고 클래스생성자 호출 불가

> 그래서 final이랑 함께 쓸 수 없다.

```java
public abstract class Mammal{}
class Lion extends Mammal {}
...
public static void main(String[] args){
    Mammal m = new Mammal(); // error, 추상클래스는 존재하지 않는클래스. 인스턴스화할수없다.
    Mammal m2 = new Lion(); // OK
}

```



메소드도 강제적으로 재정의하게 만들고싶으면 추상 메소드(abstract method)를 이용하면 된다.

@Override 강제!

```java
public abstract class Mammal{
    public abstract void cry(); // 선언만 함. Body 안만들어야함. Override안하면 에러
}
class Lion extends Mammal {
    @Override
    public void cry(){ // 이거 안하면 에러
        System.out.println("ughhh")
    }
}
```





# new

###### new 연산자

**클래스 객체 변수 =** **new** **클래스();**

간단히 설명하면 인스턴스(객체)를 생성할 때 사용하는 코드이며 객체 변수가 실제 데이터가 아닌 참조 값을 갖는다.

new는 클래스 타입의 **인스턴스(객체)를 생성해주는 역할**을 담당한다. 여기에 조금 더 설명을 붙이면 new 연산자를 통해 **메모리(Heap 영역)에 데이터를 저장할 공간을** 할당받고 그 공간의 참조값(reference value /해시코드)을 **객체에게 반환**하여 주고([메모리](http://blog.naver.com/heartflow89/220954420688), [객체 및 인스턴스](http://blog.naver.com/heartflow89/220952631257) 포스팅 참고) 이어서 **생성자를 호출**하게 된다. 인스턴스를 핸들하기 위해서는 new 연산자를 통해 참조값을 저장한 객체로만 접근이 가능하다. 정리하면 아래와 같다.

![new](../img/operator_new.png)

new : 인스턴스 생성, Heap 메모리 공간 할당, 객체에게 참조값 리턴





# 인터페이스 interface

인터페이스의 10가지 특징



```
1. interface에는 public static final이 생략된 상수만 가질 수 있다.
2. interface에는 모든 메소드가 public abstract이고 생략가능하다.
3. 이종간의 상속에는 implements 를 사용한다.
4. 부모 interface의 추상메소드를 재정의할 때에는 반드시 public 접근 지정자를 사용해야 한다.
5. interface는 추상클래스의 일종이기 때문에 역시 new로 인스턴스화할 수 없다. 그래서 다형성으로 구현해야 한다.
6. interface의 멤버는 상수이기 때문에 수정할수 없고, static이기때문에 interface이름으로 접근해야 한다.
7. interface끼리의 상속에서도 extends를 사용하며, 다중상속이 가능하다
8. interface형 주소(객체)는 본인의 추상메소드를 재정의한 메소드만 접근 가능
9. 상속받은 interface형 주소는 상속한 interface의 메소드도 접근 가능
10.interface배열에는 그 interface 자식 클래스가 멤버다.
```

*일종의* 추상클래스로, **오직 추상메서드와 상수만** 멤버로 가질수 있다. 주로 형용사형으로 네이밍한다.  

변수 : public, static, final**만** 가능하다. public, static, final을 생략할 수 있고, 오직 **상수** 만 가질 수 있다.

메소드 : public, abstract**만** 가능하다. **public, abstract**를 생략할 수 있고, 오직 추상메소드만 가질 수 있다.

```java
public interface Datable {
	// 변수는 public static final이 생략돼있다.
	int ENG = 100;
	int SUN = 0, MON = 1, TUE = 2, WED = 3, THU = 4, FRI = 5, SAT = 6;
	
	// 메소드는 body가 있으면 에러. 
	void set(int date); // public abstract가 생략돼있다.
	int get();
}

```



## 인터페이스의 상속

class가 interface를 상속받을 때는 implements (이종간 상속)

```java
// 이종간 상속에는 implements 
public class Date implements Datable {
	@Override
	public void set(int date) {

	}
    
	@Override
	public int get() {
		return 0;
	}
}

```

이 때, interface의 메소드는 모두 `public`이 생략돼있기때문에, 상속받은 클래스는 모두 public이 있어야한다.





### clone()

clone() 을 사용하려면 먼저 복제할 클래스가 Cloneable 인터페이스를 구현해야하고, clone()을 오버라이딩하면서 접근제어자를 public으로 변경한다.

```java
public class InterfaceDemo3 {
	public static void main(String[] args) {
		Demo d = new Demo(24);
		// Demo other = d.copy(); clone()메소드는 값만 복사하고 참조타입은 복사하지 않는다. 따라서 casting 필요
		Demo other = (Demo)d.copy();
		System.out.println(other.age);
	}
}

class Demo extends Object implements Cloneable{
	// implements Cloneable을 붙여야만 clone() 메소드 호출가능해짐
	// 그래서 얘(implements Cloneable)를 flag interface 라고 부른다.
	public int age;
	public Demo(int age) {
		this.age =age;
	}
    
    
	public Object copy() {
		Object obj = null;
		try {
			obj = this.clone();
		} catch (CloneNotSupportedException e) {
            // implements Cloneable 안붙이면 실행되는부분
			System.out.println("clone fail");
		}
		return obj;
	}
}
```





### Comparable 인터페이스

```java
public class Student implements Comparable <Student>{ // <Student> 는 compareTo를 통해 비교할 자료형을 넣어준다.
	String name;
	int tot;
	double avg;
	public Student(String name, int tot, double avg) {
		super();
		this.name = name;
		this.tot = tot;
		this.avg = avg;
	}
	
	@Override
	public String toString() {
		return String.format("Student [name=%s, tot=%s, avg=%s]", name, tot, avg);
	}

	@Override
	public int compareTo(Student other) {
		return this.name.compareTo(other.name);
	}	
}

```





#### instanceof 복습

instanceof는 연산자로, 참조변수(좌측)가 해당클래스(우측)로 형변환가능한 타입인지 연산합니다.

형변환이 가능하다면 true, 불가능하다면 false를 반환합니다.

`referenceVariable instanceof TargetClass`

보통 조건문과 함께 사용됩니다.

```java
class A{}
class B extends A{}

public class InstanceOfTest{
    public static void main(String[] args){
        A a = new A();
        if (a instanceof Object){
            System.out.println("Object class casting OK");
        }
        if (a instanceof A){
            System.out.println("자기자신 클래스로 형변환 가능");
        }
        if (a instanceof B){
            System.out.println("자식클래스로 형변환 가능")
        }
    }
}

// 결과 : 자식클래스로 형변환 불가능
/* 
Object class casting OK
자기자신 클래스로 형변환 가능
*/
```





---

8/11

java에서 `import dir1.dir2.ClassName; ` 으로 시작할 때, 컴파일러는 `dir1`을 어디서 찾을까?

1. current directory
2. classpath
3. Java Home > lib (JRE System library)
4. buildpath



### 인터페이스의 활용

### sort

public static void sort([Object](file:///C:/Program Files/jdk-14.0.2/docs/api/java.base/java/lang/Object.html)[] a)

Sorts the specified array of objects into ascending order, according to the [natural ordering](file:///C:/Program Files/jdk-14.0.2/docs/api/java.base/java/lang/Comparable.html) of its elements. **All elements in the array must implement the [`Comparable`](file:///C:/Program Files/jdk-14.0.2/docs/api/java.base/java/lang/Comparable.html) interface.**  Furthermore, all elements in the array must be *mutually comparable* (that is, `e1.compareTo(e2)` must not throw a `ClassCastException` for any elements `e1` and `e2` in the array).  



sort api를 쓰고싶은데, 아래 상태로는 main에서 sort()메소드를 썼을 때 에러가 발생한다.

```java
import java.util.Arrays;
public class Sort {
	Telephone[] array;

	public Sort(Telephone[] array) {this.array = array;}
	
	public void sort() {
		Arrays.sort(array); // class Telephone cannot be cast to class java.lang.Comparable
	}
}
```



class `Telephone`를 좀 고쳐줘야한다.

```java
// 1. add implements Comparable <Telephone>
// 2. override compareTo 
public class Telephone implements Comparable <Telephone>{

@Override
	public int compareTo(Telephone other) {
		if(this.fee > other.fee) return 1;
		else if(this.fee < other.fee) return -1;
		else return 0;
	}
}
```



### compareTo()

`implements Comparable`을 통해 `Comparable` 인터페이스를 상속하면 `compareTo()`라는 추상메소드를 override해야한다. 이 메소드에 대해 알아보자.

```java
@Override
public int compareTo(Car other) {
    // 오름차순
    if (this.price > other.price) return 1;
    else if (this.price < other.price) return -1;
    else return 0;
}
```

원래 compareTo() 메소드는 this의 값과 other의 값을 비교하여 더 크면 양수, 더 작으면 음수, 같으면 0을 반환하는 메소드다. 이를 오버라이드해주면 Comparable을 상속받아 Arrays.sort()를 해줄수 있다.

부등호의 방향을 바꾸면 오름차순이 내림차순으로 바뀐다는 점 정도만 알고있으면 된다.





 





## 내부 클래스 (inner class)

클래스 내에 선언되는 클래스를 내부 클래스라고 한다. 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있고, 코드의 복잡성을 줄일 수 있다는 장점이 있다.

```java
class OuterClass{
    class InnerClass{}
}
```

컴파일시에는 `OuterClass$InnerClass.class`라는 파일이 저장된다. 다른 메서드에서 같은 이름의 로컬 클래스를 생성하면 내부클래스이름앞에 숫자가 붙는다.

```java
class Outer{
    void method1(){
        class LocalInner{}
    }
    void method2(){
        class LocalInner{}
    }
}
```

컴파일시 `Outer$1LocalInner.class`, `Outer$2LocalInner.class`가 생성된다.



내부 클래스는 선언위치에 따라 4가지로 분류된다. 내부 클래스의 유효범위와 성질이 변수와 유사하므로 비교를 통해 이해에 도움을 얻을 수 있다.

- 인스턴스 클래스
- 스태틱 클래스
- 지역 클래스
- 익명 클래스



#### 인스턴스 클래스

외부클래스의 멤버변수 선언위치에 선언하며, 외부클래스의 인스턴스멤버처럼 다루어진다. 

주로 외부클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다.



#### 스태틱 클래스

외부클래스의 static 멤버처럼 다루어진다.

주로 외부클래스의 static 멤버, 특히 static method에서 사용될 목적으로 선언된다.

static member이기때문에 외부클래스의 인스턴스멤버를 사용할 수 없다.



#### 지역클래스

외부클래스의 메서드나 초기화 블럭 안에 선언한다.



#### 익명클래스

클래스의 선언과 객체의 생성을 동시에하는 이름없는 클래스.

1회용 클래스로, 단 한번만 사용되며 오직 하나의 객체만 생성한다.

오직 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만 구현할 수 있다.

```java
class Test{
    Object iv = new Object(){void method(){} }; // 익명 클래스
    static Object cv = new Object(){ void method(){} }; // 익명 클래스
    void method(){
        Object lv = new Object(){void method(){}}; // 익명 클래스
    }
}
```

컴파일 시 `Test$1.class`, `Test$2.class`, `Test$3.class`가 생성된다.



익명 클래스는 클래스 생성자 뒤에 들어가는데, 여기서 해당 클래스의 메소드를 오버라이드할 수 있다.

```java
public class AnonymousClassDemo {
	public static void main(String[] args) {
				
		Product keyboard = new Product("샘숭", 20000) {
			@Override
			public void print() {
				System.out.println("Hello, World");
			}
		};
		keyboard.print();
	}
}
class Product{
    ...
	public void print() {
		System.out.println("name = " + this.name + ", price = " + this.price);
	}
}
```



위의 경우, Product 클래스 내에 있는 print() 메소드 대신 익명클래스 내에서 override된 print()가 실행되어 `Hello, World`가 출력된다.



## enum

Enumeration은 프로그래밍언어에서 **상수의 그룹**을 나타낼 때 사용한다.

```java
enum Color {
	RED, GREEN, BLUE
}

/* 내부적으로 위의 enum은 아래처럼 바뀐다.
class Color
{
     public static final Color RED = new Color();
     public static final Color BLUE = new Color();
     public static final Color GREEN = new Color();
}*/
```

enum은 생성자를 가질 수 있고 enum 클래스가 로드 될 때 각 상수들이 개별적으로 실행된다. **(1)**

enum 객체를 명시적으로 생성할 수 없으므로 enum 생성자를 직접 부를 수는 없다. (new Color() 형식으로 부를 수 없음)

그래서 values()를 이용하여 생성해준다. **(2)**

#### values()

**values()** 메소드는 enum안에 존재하는 모든 값들을 반환한다.



#### ordinal()

enum안에서 순서는 중요하다. **ordinal()** 메소드를 사용하여 배열 인덱스처럼 각 enum 상수 인덱스를 찾을 수 있다. **(3)**



위의 내용들이 포함된 코드는 아래와 같다.

```java
public enum Week {
	SUN(0), MON(100), TUE(101), WED(1000), THU(1001), FRI(10000), SAT(50000);
	private int value;
	
	Week(int value){ // (1)
		this.value = value;
	}
	public int getValue() {return this.value;}
}


public class EnumDemo {
	public static void main(String[] args) {
		Week[] array = Week.values(); // (2)
		for (Week w : array) {
			System.out.print(w);
			System.out.print(", " + w.getValue());
			System.out.println(", " + w.ordinal()); // (3)
		}
	}
}

/*
결과 : 
요일, 값, 인덱스
SUN, 0, 0
MON, 100, 1
TUE, 101, 2
WED, 1000, 3
THU, 1001, 4
FRI, 10000, 5
SAT, 50000, 6
*/
```



- 모든 enum은 상수는 내부적으로 **public static final** 으로 정의되고, enum 이름으로 사용할 수있다. **final**이므로 자식 enum을 만들 수는 없다.
- enum 내부에 **main()** 메서드를 선언할 수 있다. 그래서 enum을 커맨드 프롬프트에서 직접 호출할 수 있다.



---

# Exception