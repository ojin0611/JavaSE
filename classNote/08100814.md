08/10

instanceof 복습





## 다른 경로에 있는 파일 저장/ 불러오기

다양한 옵션이 있다.

1. package import
2. classpath
3. jar



> 테스트는 D드라이브 아무 폴더를 기준으로 진행되고있습니다. 



### 파일 저장. package

#### cmd

컴파일 결과인 클래스파일의 저장경로는 현재 경로가 default다. 이 저장경로를 바꾸기위해서는 `-d mydirectory`를 이용한다.

```
javac -d C:/Temp Employee.java
```

> 위를 실행하면 현재 경로에있는 Employee.java를 실행하고, C:/Temp에 Employee.class를 저장한다.



Main.java에 있는 main 함수가 **같은 경로 내에 있는** Employee.java에 있는 Employee 클래스를 가져다쓴다고 해보자. 

```
javac Main.java
```

> 위를 실행하면 컴파일결과로 현재 폴더에 Main.class와 Employee.class를 생성한다.
>
> 자바는 메인을 실행했을 때, **자바 파일**을 찾아가서, 해당파일의 클래스가 없다면 그 때 생성한다.



#### java

자바파일에서 저장경로를 설정할 때 **package** 를 이용해준다.

```java
package kr.co.sist.libs;

public class Employee{
    public String name = "Sally";
}
```

>  위의 컴파일 구문 `javac -d C:/Temp Employee.java`를 실행하면 현재 경로에있는 Employee.java를 실행하고 C:/Temp/kr/co/sist/libs 에 Employee.class를 저장한다.





### 파일 불러오기. import, classpath, jar

#### 1. 같은 패키지

같은 패키지에 있는 파일은 불러오는데 문제가 없지만 다른 패키지에 있는 파일은 인식을 못한다.

다른 패키지에 저장돼있는 java, class 파일을 불러오고싶을 때 **import** 를 이용한다.

> import문은 package문 다음, class선언 이전에 선언한다.



```java
import kr.co.sist.libs.Employee;

public class Main {
	public static void main(String[] args) {
		Employee emp = new Employee();
		System.out.println("Name = " + emp.name);
	}
}

// 근데 이상태에서 `javac Main.java` 하면 에러 난다. 컴파일러가 저 디렉토리를 못찾는다.
```



static import라는 녀석도 있는데, 이를 사용하면 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

```java
import static java.lang.System.out;
import static java.lang.Math.*;

public class StaticImportDemo {
	public static void main(String[] args) {
		out.println("Hello, World");  // System 생략 가능!
		out.println("Real Pi = "+PI); // Math 생략가능! 3.141592653589793
		
		double rand = random(); // 내가 만든 메소드가 먼저나옴~ㅋㅋ
		out.println("My random double = " + rand); // 2.718
	}
	
	static double random() {
		out.println("Fake random ^^");
		return 2.718;
	}
}

```





#### 2. classpath



아래 두가지 경우도 가능하지만 보통 위의 경우가 대부분 쓰인다.

> import kr.co.sist.libs.*;
>
> kr.co.sist.libs.Employee emp = new kr.co.sist.libs.Employee();



다른 경로에 있는 파일을 불러오고싶을때는 cmd에서 **classpath (또는 -cp)**를 사용한다.

```
java -cp .;C:/Temp Main
```



클래스경로 (classpath)를 매번 지정하기 귀찮으니까 환경변수 > 시스템변수에 추가해주자.

> 환경변수 > 시스템변수 > 변수:CLASSPATH , 값: .;C:/Temp
>
> 띄어쓰기하면 에러

이렇게 하면 `javac Main.java` `java Main`이 먹힌다!

 

#### 3. jar

파일을 불러오는 기본 경로에 JRE System Library가 있다.

jar 파일을 만들어서 JRE System Library에 넣어도되고, 패키지에 별도의 경로(Reference Library)를 추가해주면 된다.



#### jar 만드는 방법

> 도움말은 cmd에서 jar --help를 쳐본다.



`C:\Temp> jar cvf mylib.jar kr/`

jar : jar파일 만들게

-c : create the archive

-v : verbose. generate verbose output on standard output

-f : archive file name.

mylib.jar : 파일이름

kr/ : 폴더 kr 이하에 있는 모든 파일들을 묶겠다는 뜻!



#### 새로운 경로 Eclipse에 저장하기

eclipse > 프로젝트 위에 우클릭 > Build path > Libraries > Classpath 선택 > Add External JARs > jar파일 선택 > Apply

그러면 해당 프로젝트 안에 Referenced Libraries가 생긴다.



## 제어자 (modifier)

제어자는 접근제어자와 그외로 나눌수 있다.

접근 제어자 (access modifier)

- public : 같은 클래스, 같은 패키지, 자손 클래스와 그 밖에서도 접근가능하다.
- protected : 같은 클래스, 같은 패키지, 자손클래스에서만 접근가능
- (default) : 따로 선언하지않으면 default. 같은 클래스와 패키지
- private : 오직 같은 클래스 내에서



그 외

- static, final, abstract, native, transient, synchronized



### final 

변수를 상수로 만들어준다.

상수이름은 모두 대문자, 중간구분은 `_`

클래스를 더이상 상속할 수 없게 만들어준다.



까먹을까봐 다시 정리..

>  멤버변수(+상수) 초기화는 생성자
>
> 클래스변수(+상수) 초기화는 초기화블럭 



### abstract

abstract class = 추상클래스.  미완성 설계도에 비유할 수 있다.

미완성 메서드(abstract method)를 포함하고있다는 의미다.

목적은 **다형성의 강제화**로 상속을 통해 구현해주어야한다. 상속안하고 클래스생성자 호출 불가

> 그래서 final이랑 함께 쓸 수 없다.

```java
public abstract class Mammal{}
class Lion extends Mammal {}
...
public static void main(String[] args){
    Mammal m = new Mammal(); // error, 추상클래스는 존재하지 않는클래스. 인스턴스화할수없다.
    Mammal m2 = new Lion(); // OK
}

```



메소드도 강제적으로 재정의하게 만들고싶으면 추상 메소드(abstract method)를 이용하면 된다.

@Override 강제!

```java
public abstract class Mammal{
    public abstract void cry(); // 선언만 함. Body 안만들어야함. Override안하면 에러
}
class Lion extends Mammal {
    @Override
    public void cry(){ // 이거 안하면 에러
        System.out.println("ughhh")
    }
}
```





# new

###### new 연산자

**클래스 객체 변수 =** **new** **클래스();**

간단히 설명하면 인스턴스(객체)를 생성할 때 사용하는 코드이며 객체 변수가 실제 데이터가 아닌 참조 값을 갖는다.

new는 클래스 타입의 **인스턴스(객체)를 생성해주는 역할**을 담당한다. 여기에 조금 더 설명을 붙이면 new 연산자를 통해 **메모리(Heap 영역)에 데이터를 저장할 공간을** 할당받고 그 공간의 참조값(reference value /해시코드)을 **객체에게 반환**하여 주고([메모리](http://blog.naver.com/heartflow89/220954420688), [객체 및 인스턴스](http://blog.naver.com/heartflow89/220952631257) 포스팅 참고) 이어서 **생성자를 호출**하게 된다. 인스턴스를 핸들하기 위해서는 new 연산자를 통해 참조값을 저장한 객체로만 접근이 가능하다. 정리하면 아래와 같다.

![new](../img/operator_new.png)

new : 인스턴스 생성, Heap 메모리 공간 할당, 객체에게 참조값 리턴





# 인터페이스 interface

인터페이스의 10가지 특징



```
1. interface에는 public static final이 생략된 상수만 가질 수 있다.
2. interface에는 모든 메소드가 public abstract이고 생략가능하다.
3. 이종간의 상속에는 implements 를 사용한다.
4. 부모 interface의 추상메소드를 재정의할 때에는 반드시 public 접근 지정자를 사용해야 한다.
5. interface는 추상클래스의 일종이기 때문에 역시 new로 인스턴스화할 수 없다. 그래서 다형성으로 구현해야 한다.
6. interface의 멤버는 상수이기 때문에 수정할수 없고, static이기때문에 interface이름으로 접근해야 한다.
7. interface끼리의 상속에서도 extends를 사용하며, 다중상속이 가능하다
8. interface형 주소(객체)는 본인의 추상메소드를 재정의한 메소드만 접근 가능
9. 상속받은 interface형 주소는 상속한 interface의 메소드도 접근 가능
10.interface배열에는 그 interface 자식 클래스가 멤버다.
```

*일종의* 추상클래스로, **오직 추상메서드와 상수만** 멤버로 가질수 있다. 주로 형용사형으로 네이밍한다.  

변수 : public, static, final**만** 가능하다. public, static, final을 생략할 수 있고, 오직 **상수** 만 가질 수 있다.

메소드 : public, abstract**만** 가능하다. **public, abstract**를 생략할 수 있고, 오직 추상메소드만 가질 수 있다.

```java
public interface Datable {
	// 변수는 public static final이 생략돼있다.
	int ENG = 100;
	int SUN = 0, MON = 1, TUE = 2, WED = 3, THU = 4, FRI = 5, SAT = 6;
	
	// 메소드는 body가 있으면 에러. 
	void set(int date); // public abstract가 생략돼있다.
	int get();
}

```



## 인터페이스의 상속

class가 interface를 상속받을 때는 implements (이종간 상속)

```java
// 이종간 상속에는 implements 
public class Date implements Datable {
	@Override
	public void set(int date) {

	}
    
	@Override
	public int get() {
		return 0;
	}
}

```

이 때, interface의 메소드는 모두 `public`이 생략돼있기때문에, 상속받은 클래스는 모두 public이 있어야한다.





### clone()

clone() 을 사용하려면 먼저 복제할 클래스가 Cloneable 인터페이스를 구현해야하고, clone()을 오버라이딩하면서 접근제어자를 public으로 변경한다.

```java
public class InterfaceDemo3 {
	public static void main(String[] args) {
		Demo d = new Demo(24);
		// Demo other = d.copy(); clone()메소드는 값만 복사하고 참조타입은 복사하지 않는다. 따라서 casting 필요
		Demo other = (Demo)d.copy();
		System.out.println(other.age);
	}
}

class Demo extends Object implements Cloneable{
	// implements Cloneable을 붙여야만 clone() 메소드 호출가능해짐
	// 그래서 얘(implements Cloneable)를 flag interface 라고 부른다.
	public int age;
	public Demo(int age) {
		this.age =age;
	}
    
    
	public Object copy() {
		Object obj = null;
		try {
			obj = this.clone();
		} catch (CloneNotSupportedException e) {
            // implements Cloneable 안붙이면 실행되는부분
			System.out.println("clone fail");
		}
		return obj;
	}
}
```





### compareTo()

```java
public class Student implements Comparable <Student>{
	String name;
	int tot;
	double avg;
	public Student(String name, int tot, double avg) {
		super();
		this.name = name;
		this.tot = tot;
		this.avg = avg;
	}
	
	@Override
	public String toString() {
		return String.format("Student [name=%s, tot=%s, avg=%s]", name, tot, avg);
	}

	@Override
	public int compareTo(Student other) {
		return this.name.compareTo(other.name);
	}	
}

```



#### instanceof 복습

instanceof는 연산자로, 참조변수(좌측)가 해당클래스(우측)로 형변환가능한 타입인지 연산합니다.

형변환이 가능하다면 true, 불가능하다면 false를 반환합니다.

`referenceVariable instanceof TargetClass`

보통 조건문과 함께 사용됩니다.

```java
class A{}
class B extends A{}

public class InstanceOfTest{
    public static void main(String[] args){
        A a = new A();
        if (a instanceof Object){
            System.out.println("Object class casting OK");
        }
        if (a instanceof A){
            System.out.println("자기자신 클래스로 형변환 가능");
        }
        if (a instanceof B){
            System.out.println("자식클래스로 형변환 가능")
        }
    }
}

// 결과 : 자식클래스로 형변환 불가능
/* 
Object class casting OK
자기자신 클래스로 형변환 가능
*/
```

